#!/usr/bin/perl

use warnings;
use strict;

use File::Copy qw(move copy);
use Getopt::Std qw(getopts);

sub usage;
sub fatal;

$| = 1;

my %ext2coll = qw(
    .jpg    photos
    .jpeg   photos
    .avi    videos
    .mp4    videos
    .mpg    videos
    .mpeg   videos
);
my %coll2namer;

(my $prog = $0) =~ s{.+/}{};
my $root = $ENV{UFO_ROOT} ||= glob('~/var/ufo') || glob('~/.ufo') || fatal "Can't determine ufo root directory";
my %opt;

&{ __PACKAGE__->can(@ARGV ? 'cmd_' . shift : usage) || usage };

# --- Main functions

sub cmd_import {
    getopts(':h:xXr:vn', \%opt) or usage;
    $opt{x} = 1 if $opt{X};
    @ARGV = argv2files();
    my $hashf = $opt{h} || "/tmp/ufo.$$.sha256sum";
    if (!$opt{h} || ! -s $hashf) {
        print STDERR "Saving checksums to $hashf";
        my $hashes = sha256hashes($hashf, @ARGV);
        print STDERR "\n";
    }
    open my $hashfh, '<', $hashf or fatal "open $hashf: $!";
    my (@imported, @already_imported);
    while (<$hashfh>) {
        my ($hash, $f) = split /\s+\*?/, $_, 2;
        chomp $f;
        print "> $f\n";
        my $m = mpath($hash, $f);
        if (!defined $m) {
            print "? no collection\n" if $opt{v};
            next;
        }
        elsif (-e $m) {
            print "- $m\n";
            push @already_imported, $f if $opt{X};
        }
        else {
            copy $f, $m or fatal "copy $f $m: $!" if !$opt{n};
            print "+ $m\n";
            push @imported, $f;
        }
    }
    continue {
        print "\n";
    }
    return if $opt{n} || !$opt{x};
    foreach my $f (@imported, @already_imported) {
        unlink $f;
    }
}

sub cmd_check {
    my @files = argv2files(@ARGV);
    usage if !@ARGV;
    my $hashes = sha256hashes(undef, @files);
    foreach my $f (@files) {
        my $hash = $hashes->{$f};
        my $m = mpath($hash, $f);
        if (!defined $m) {
            print STDERR "No collection: $f\n";
        }
        elsif (-e $m) {
            print STDERR "- $hash $f\n";
        }
        else {
            print STDERR "+ $hash $f\n";
        }
    }
}

# --- Other functions

sub ext {
    my ($f) = @_;
    return if $f !~ m{(\.[^/]+)$};
    return lc $1;
}

sub mpath {
    my ($hash, $f) = @_;
    my $ext = ext($f) or return;
    my $coll = $ext2coll{$ext};
    return if !defined $coll;
    my $namer = coll2namer($coll);
    return $namer->($hash, $ext);
}

sub argv2files {
    my @argv = @ARGV;
    my @files;
    if (@argv) {
        # Nothing special to do
    }
    elsif (-t STDIN) {
        @argv = qw(.);
    }
    else {
        # Read files from standard input
        @argv = <STDIN>;
        chomp @argv;
    }
    while (@argv) {
        my $f = shift @argv;
        if (-d $f) {
            unshift @argv, grep {
                my $ext = ext($_);
                defined $ext && defined $ext2coll{$ext};
            } glob("$f/*");
        }
        elsif (-f _) {
            push @files, $f;
        }
        else {
            # Not a file or directory
        }
    }
    return @files;
}

sub coll2namer {
    my ($coll) = @_;
    return $coll2namer{$coll} if defined $coll2namer{$coll};
    my $mroot = "$root/$coll";
    my @dirs2 = grep { m{/[0-9a-f]{2}$}i && -d } glob("$mroot/00/??");
    my @dirs1 = grep { m{/[0-9a-f]{2}$}i && -d } glob("$mroot/??");
    my $namer;
    if (@dirs2) {
        $namer = sub {
            my ($hash, $ext) = @_;
            sprintf '%s/%s/%s/%s%s', $mroot, substr($hash,0,2), substr($hash,2,2), $hash, $ext;
        }
    }
    elsif (@dirs1) {
        $namer = sub {
            my ($hash, $ext) = @_;
            sprintf '%s/%s/%s%s', $mroot, substr($hash,0,2), $hash, $ext;
        }
    }
    else {
        $namer = sub {
            my ($hash, $ext) = @_;
            sprintf '%s/%s%s', $mroot, $hash, $ext;
        }
    }
    return $coll2namer{$coll} = $namer;
}

sub sha256hashes {
    my $hashf = shift;
    return if !@_;
    my ($hashfh, $procfh, %hash);
    if (defined $hashf) {
        open $hashfh, '>', $hashf or fatal "open $hashf: $!";
    }
    open $procfh, '-|', 'sha256sum', @_ or fatal "sha256sum: $!";
    while (<$procfh>) {
        chomp;
        my ($hash, $f) = split /\s+\*?/, $_, 2;
        print $hashfh $_ if defined $hashfh;
        $hash{$f} = $hash;
    }
    return \%hash;
}

sub fatal {
    print STDERR $prog, ": @_\n";
    exit 1;
}
